{"version":3,"names":[],"mappings":"","sources":["ccwc-glvideo.js"],"sourcesContent":["if (!window.ccwc) { ccwc = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image.webgl) { ccwc.image.webgl = {}; }\r\n\r\nccwc.image.webgl.filter = {\r\n    /**\r\n     * create filter from shaders\r\n     * @param vertexShader\r\n     * @param fragmentShader\r\n     * @returns {{vertexShader: *, fragmentShader: *}}\r\n     */\r\n    createFilterFromShaders: function(vertexShader, fragmentShader) {\r\n        return { vertexShader: vertexShader, fragmentShader: fragmentShader };\r\n    },\r\n\r\n    /**\r\n     * create a filter from filter name\r\n     * @param name\r\n     * @param memory space/variable to pull shader from\r\n     */\r\n    createFilterFromName: function(name, shaderloc) {\r\n        if (!shaderloc) {\r\n            shaderloc = ccwc.image.webgl.shaders;\r\n        }\r\n        var vtx = shaderloc[name].vertex;\r\n        var frg = shaderloc[name].fragment;\r\n        return this.createFilterFromShaders(vtx, frg);\r\n    },\r\n\r\n    /**\r\n     * create object for render\r\n     * @param webglcontext\r\n     * @param filter\r\n     */\r\n    createRenderProps: function(webglcontext, filter, textures, textureWidth, textureHeight) {\r\n        var props = {};\r\n        if (!webglcontext) {\r\n            var canvas = document.createElement('canvas')\r\n            props.gl = canvas.getContext('webgl');\r\n        } else {\r\n            props.gl = webglcontext;\r\n        }\r\n\r\n        if (!textures.length) {\r\n            textures = [textures];\r\n        }\r\n        props.filter = filter;\r\n        props.textures = textures;\r\n        props.glTextures = [];\r\n        props.glTextureIndices = [];\r\n        props.flipTexture = false;\r\n\r\n        for (var c = 0; c < props.textures.length; c++) {\r\n            props.glTextureIndices.push(c);\r\n        }\r\n\r\n        props.textureWidth = textureWidth;\r\n        props.textureHeight = textureHeight;\r\n\r\n        props.canvas2DHelper = document.createElement('canvas');\r\n        props.canvas2DHelper.width = props.textureWidth;\r\n        props.canvas2DHelper.height = props.textureHeight;\r\n        props.canvas2DHelperContext = props.canvas2DHelper.getContext('2d');\r\n        props.uniforms = new ccwc.image.webgl.uniforms();\r\n\r\n        return props;\r\n    },\r\n\r\n    /**\r\n     * render WebGL filter on current texture\r\n     * @param glprops\r\n     * @param refreshTextureIndices texture refresh indices (optional)\r\n     * @returns {*}\r\n     */\r\n    render: function(glprops, refreshTextureIndices) {\r\n        var glctx = glprops.gl;\r\n\r\n        if (!refreshTextureIndices) {\r\n            // refresh all textures unless specifying otherwise\r\n            refreshTextureIndices = glprops.glTextureIndices;\r\n        }\r\n\r\n        if (!glprops.isInitialized) {\r\n            var vertexShader = glctx.createShader(glctx.VERTEX_SHADER);\r\n            glctx.shaderSource(vertexShader, glprops.filter.vertexShader);\r\n            glctx.compileShader(vertexShader);\r\n\r\n            var fragmentShader = glctx.createShader(glctx.FRAGMENT_SHADER);\r\n            glctx.shaderSource(fragmentShader, glprops.filter.fragmentShader);\r\n            glctx.compileShader(fragmentShader);\r\n\r\n            glprops.program = glctx.createProgram();\r\n            glctx.attachShader(glprops.program, vertexShader);\r\n            glctx.attachShader(glprops.program, fragmentShader);\r\n            glctx.linkProgram(glprops.program);\r\n            glctx.useProgram(glprops.program);\r\n\r\n            for (var c = 0; c < glprops.textures.length; c++) {\r\n                glprops.glTextures.push(glctx.createTexture());\r\n            }\r\n\r\n            var positionLocation = glctx.getAttribLocation(glprops.program, 'a_position');\r\n            var texCoordBuffer = glctx.createBuffer();\r\n            var rectCoordBuffer = glctx.createBuffer();\r\n            var texCoords = new Float32Array([0.0,  0.0, 1.0,  0.0, 0.0,  1.0, 0.0,  1.0, 1.0,  0.0, 1.0,  1.0]);\r\n            var rectCoords = new Float32Array([0, 0, glprops.textureWidth, 0, 0, glprops.textureHeight, 0,\r\n                glprops.textureHeight, glprops.textureWidth, 0, glprops.textureWidth, glprops.textureHeight]);\r\n\r\n            glctx.bindBuffer(glctx.ARRAY_BUFFER, texCoordBuffer);\r\n            glctx.bufferData(glctx.ARRAY_BUFFER, texCoords, glctx.STATIC_DRAW);\r\n\r\n            var texCoordLocation = glctx.getAttribLocation(glprops.program, 'a_texCoord');\r\n            glctx.enableVertexAttribArray(texCoordLocation);\r\n            glctx.vertexAttribPointer(texCoordLocation, 2, glctx.FLOAT, false, 0, 0);\r\n        }\r\n\r\n        if (!glprops.isInitialized) {\r\n            for (var c = 0; c < refreshTextureIndices.length; c++) {\r\n                glctx.bindTexture(glctx.TEXTURE_2D, glprops.glTextures[refreshTextureIndices[c]]);\r\n                glctx.texParameteri(glctx.TEXTURE_2D, glctx.TEXTURE_WRAP_S, glctx.CLAMP_TO_EDGE);\r\n                glctx.texParameteri(glctx.TEXTURE_2D, glctx.TEXTURE_WRAP_T, glctx.CLAMP_TO_EDGE);\r\n                glctx.texParameteri(glctx.TEXTURE_2D, glctx.TEXTURE_MIN_FILTER, glctx.NEAREST);\r\n                glctx.texParameteri(glctx.TEXTURE_2D, glctx.TEXTURE_MAG_FILTER, glctx.NEAREST);\r\n                glctx.pixelStorei(glctx.UNPACK_FLIP_Y_WEBGL, glprops.flipTexture);\r\n                glctx.texImage2D(glctx.TEXTURE_2D, 0, glctx.RGBA, glctx.RGBA, glctx.UNSIGNED_BYTE, glprops.textures[refreshTextureIndices[c]]);\r\n            }\r\n\r\n            /*var resolutionLocationVertex = glctx.getUniformLocation(glprops.program, 'u_resolution');\r\n            var resolutionLocationFragment = glctx.getUniformLocation(glprops.program, 'f_resolution');\r\n            glctx.uniform2f(resolutionLocationVertex, glctx.canvas.width, glctx.canvas.height);\r\n            glctx.uniform2f(resolutionLocationFragment, glctx.canvas.width, glctx.canvas.height);*/\r\n\r\n            glprops.uniforms.add('u_resolution', ccwc.image.webgl.uniforms.UNIFORM2f, [glctx.canvas.width, glctx.canvas.height]);\r\n            glprops.uniforms.add('f_resolution', ccwc.image.webgl.uniforms.UNIFORM2f, [glctx.canvas.width, glctx.canvas.height]);\r\n\r\n            for (var c = 0; c < refreshTextureIndices.length; c++) {\r\n                var u_imageLocation = glctx.getUniformLocation(glprops.program, 'u_image' + refreshTextureIndices[c]);\r\n                glctx.uniform1i(u_imageLocation, refreshTextureIndices[c]);\r\n                glctx.activeTexture(glctx['TEXTURE' + refreshTextureIndices[c]]);\r\n                glctx.bindTexture(glctx.TEXTURE_2D, glprops.glTextures[refreshTextureIndices[c]]);\r\n            }\r\n\r\n            glctx.bindBuffer(glctx.ARRAY_BUFFER, rectCoordBuffer);\r\n            glctx.enableVertexAttribArray(positionLocation);\r\n            glctx.vertexAttribPointer(positionLocation, 2, glctx.FLOAT, false, 0, 0);\r\n            glctx.bufferData(glctx.ARRAY_BUFFER, rectCoords, glctx.STATIC_DRAW);\r\n        } else {\r\n            for (var c = 0; c < refreshTextureIndices.length; c++) {\r\n                glctx.bindTexture(glctx.TEXTURE_2D, glprops.glTextures[refreshTextureIndices[c]]);\r\n                glctx.texSubImage2D(glctx.TEXTURE_2D, 0, 0, 0, glctx.RGBA, glctx.UNSIGNED_BYTE, glprops.textures[refreshTextureIndices[c]]);\r\n            }\r\n        }\r\n\r\n        glprops.uniforms.updateProgram(glctx, glprops.program);\r\n        glctx.drawArrays(glctx.TRIANGLES, 0, 6);\r\n        glprops.isInitialized = true;\r\n\r\n        return glprops;\r\n    },\r\n\r\n    /**\r\n     * read pixels from GL context\r\n     * @param glProps\r\n     */\r\n    getCanvasPixels: function(glprops) {\r\n        var glctx = glprops.gl;\r\n        if (!glprops.pixelarray) {\r\n            glprops.pixelarray = new Uint8Array(glctx.canvas.width * glctx.canvas.height * 4);\r\n        }\r\n        glctx.readPixels(0, 0, glctx.canvas.width, glctx.canvas.height, glctx.RGBA, glctx.UNSIGNED_BYTE, glprops.pixelarray);\r\n        var imgData = glprops.canvas2DHelperContext.createImageData(glctx.canvas.width, glctx.canvas.height);\r\n        imgData.data.set(new Uint8ClampedArray(glprops.pixelarray));\r\n        return imgData;\r\n    }\r\n};\nccwc.image.webgl.shaders = {\n  \"freichen_edge_detection\": {\n    \"fragment\": \"precision mediump float; uniform sampler2D u_image; varying vec2 v_texCoord; uniform vec2 f_resolution; vec2 texel = vec2(1.0 / f_resolution.x, 1.0 / f_resolution.y); mat3 G[9];  const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 ); const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 ); const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 ); const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 ); const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 ); const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 ); const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 ); const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 ); const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );  void main(void) {      G[0] = g0,     G[1] = g1,     G[2] = g2,     G[3] = g3,     G[4] = g4,     G[5] = g5,     G[6] = g6,     G[7] = g7,     G[8] = g8;      mat3 I;     float cnv[9];     vec3 sampl;      for (float i=0.0; i<3.0; i++) {         for (float j=0.0; j<3.0; j++) {             sampl = texture2D(u_image, v_texCoord + texel * vec2(i-1.0,j-1.0) ).rgb;             I[int(i)][int(j)] = length(sampl);         }     }      for (int i=0; i<9; i++) {         float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);         cnv[i] = dp3 * dp3;     }      float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);     float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);      gl_FragColor = vec4(vec3(sqrt(M/S)), texture2D( u_image, v_texCoord ).a ); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"greyscale\": {\n    \"fragment\": \"precision mediump float; varying vec2 v_texCoord;  uniform sampler2D u_image;  void main(void) {     vec4 px = texture2D(u_image, v_texCoord);     float avg = (px.r + px.g + px.b)/3.0;     gl_FragColor = vec4(avg, avg, avg, px.a); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"passthrough\": {\n    \"fragment\": \"precision mediump float; uniform sampler2D u_image; varying vec2 v_texCoord;  void main() {     gl_FragColor = texture2D(u_image, v_texCoord); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"sepia\": {\n    \"fragment\": \"precision mediump float; varying vec2 v_texCoord;  uniform sampler2D u_image; uniform vec4 light; uniform vec4 dark; uniform float desat; uniform float toned;  const mat4 coeff = mat4(     0.393, 0.349, 0.272, 1.0,     0.796, 0.686, 0.534, 1.0,     0.189, 0.168, 0.131, 1.0,     0.0, 0.0, 0.0, 1.0 );  void main(void) {     vec4 sourcePixel = texture2D(u_image, v_texCoord);     gl_FragColor = coeff * sourcePixel; }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"sobel_edge_detection\": {\n    \"fragment\": \"precision mediump float; varying vec2 v_texCoord; uniform sampler2D u_image; uniform vec2 f_resolution;  void main(void) {     float x = 1.0 / f_resolution.x;     float y = 1.0 / f_resolution.y;     vec4 horizEdge = vec4( 0.0 );     horizEdge -= texture2D( u_image, vec2( v_texCoord.x - x, v_texCoord.y - y ) ) * 1.0;     horizEdge -= texture2D( u_image, vec2( v_texCoord.x - x, v_texCoord.y     ) ) * 2.0;     horizEdge -= texture2D( u_image, vec2( v_texCoord.x - x, v_texCoord.y + y ) ) * 1.0;     horizEdge += texture2D( u_image, vec2( v_texCoord.x + x, v_texCoord.y - y ) ) * 1.0;     horizEdge += texture2D( u_image, vec2( v_texCoord.x + x, v_texCoord.y     ) ) * 2.0;     horizEdge += texture2D( u_image, vec2( v_texCoord.x + x, v_texCoord.y + y ) ) * 1.0;     vec4 vertEdge = vec4( 0.0 );     vertEdge -= texture2D( u_image, vec2( v_texCoord.x - x, v_texCoord.y - y ) ) * 1.0;     vertEdge -= texture2D( u_image, vec2( v_texCoord.x    , v_texCoord.y - y ) ) * 2.0;     vertEdge -= texture2D( u_image, vec2( v_texCoord.x + x, v_texCoord.y - y ) ) * 1.0;     vertEdge += texture2D( u_image, vec2( v_texCoord.x - x, v_texCoord.y + y ) ) * 1.0;     vertEdge += texture2D( u_image, vec2( v_texCoord.x    , v_texCoord.y + y ) ) * 2.0;     vertEdge += texture2D( u_image, vec2( v_texCoord.x + x, v_texCoord.y + y ) ) * 1.0;     vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));      gl_FragColor = vec4( edge, texture2D( u_image, v_texCoord ).a ); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  }\n};\nif (!window.ccwc) { ccwc = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image.webgl) { ccwc.image.webgl = {}; }\r\n\r\nccwc.image.webgl.uniforms = function() {\r\n    /**\r\n     * internal mapping of uniforms\r\n     * @type {{}}\r\n     * @private\r\n     */\r\n    this._uniforms = {};\r\n\r\n    /**\r\n     * add a uniform\r\n     * @param type type of uniform (1f, 2f, 3f, 4f, 1i, 2i, 3i, 4u\r\n     */\r\n    this.add = function(name, type, values) {\r\n        this._uniforms[name] = { name: name, type: type, values: values, dirty: true };\r\n    };\r\n\r\n    /**\r\n     * update a uniform\r\n     * @param type type of uniform (1f, 2f, 3f, 4f, 1i, 2i, 3i, 4u\r\n     */\r\n    this.update = function(name, values) {\r\n        this._uniforms[name].values = values;\r\n        this._uniforms[name].dirty = true;\r\n    };\r\n\r\n\r\n    /**\r\n     * update uniforms on GL context and program\r\n     * @param gl WebGL context\r\n     * @param program\r\n     */\r\n    this.updateProgram = function(gl, program) {\r\n        for (var c in this._uniforms) {\r\n            if (this._uniforms[c].dirty) {\r\n                var u = gl.getUniformLocation(program, this._uniforms[c].name);\r\n                switch (this._uniforms[c].type) {\r\n                    case '1f':\r\n                        gl.uniform1f(u, this._uniforms[c].values[0]);\r\n                        break;\r\n\r\n                    case '2f':\r\n                        gl.uniform2f(u, this._uniforms[c].values[0], this._uniforms[c].values[1]);\r\n                        break;\r\n\r\n                    case '3f':\r\n                        gl.uniform3f(u, this._uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2]);\r\n                        break;\r\n\r\n                    case '4f':\r\n                        gl.uniform4f(u, this._uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2], this._uniforms[c].values[3]);\r\n                        break;\r\n\r\n                    case '1i':\r\n                        gl.uniform1i(u, this._uniforms[c].values[0]);\r\n                        break;\r\n\r\n                    case '2i':\r\n                        gl.uniform2i(u, this._uniforms[c].values[0], this._uniforms[c].values[1]);\r\n                        break;\r\n\r\n                    case '3i':\r\n                        gl.uniform3i(u, this._.uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2]);\r\n                        break;\r\n\r\n                    case '4i':\r\n                        gl.uniformif(u, this._uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2], this._uniforms[c].values[3]);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\n\r\nccwc.image.webgl.uniforms.UNIFORM1f = '1f';\r\nccwc.image.webgl.uniforms.UNIFORM2f = '2f';\r\nccwc.image.webgl.uniforms.UNIFORM3f = '3f';\r\nccwc.image.webgl.uniforms.UNIFORM4f = '4f';\r\n\r\nccwc.image.webgl.uniforms.UNIFORM1i = '1i';\r\nccwc.image.webgl.uniforms.UNIFORM2i = '2i';\r\nccwc.image.webgl.uniforms.UNIFORM3i = '3i';\r\nccwc.image.webgl.uniforms.UNIFORM4i = '4i';\n/**\r\n * CCWCVideo supports both video files and camera feeds\r\n * Blit your video to a canvas, get frame data, scale the frame/canvas output, and render video to an external canvas of your choosing\r\n */\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CCWCVideo = (function (_HTMLElement) {\n    _inherits(CCWCVideo, _HTMLElement);\n\n    function CCWCVideo() {\n        _classCallCheck(this, CCWCVideo);\n\n        _get(Object.getPrototypeOf(CCWCVideo.prototype), 'constructor', this).apply(this, arguments);\n    }\n\n    _createClass(CCWCVideo, [{\n        key: 'setProperties',\n\n        /**\r\n         * initialize default class properties\r\n         * @private\r\n         */\n        value: function setProperties() {\n            /**\r\n             * video source file or stream\r\n             * @type {string}\r\n             * @private\r\n             */\n            this._source = '';\n\n            /**\r\n             * use webgl\r\n             * @type {boolean}\r\n             * @private\r\n             */\n            this._useWebGL = false;\n\n            /**\r\n             * use camera\r\n             * @type {boolean}\r\n             * @private\r\n             */\n            this._useCamera = false;\n\n            /**\r\n             * is component ready\r\n             * @type {boolean}\r\n             */\n            this.isReady = false;\n\n            /**\r\n             * is video playing\r\n             * @type {boolean}\r\n             */\n            this.isPlaying = false;\n\n            /**\r\n             * width of scaled video\r\n             * @type {int}\r\n             */\n            this.videoScaledWidth = 0;\n\n            /**\r\n             * width of scaled video\r\n             * @type {int}\r\n             */\n            this.videoScaledWidth = 0;\n\n            /**\r\n             * height of scaled video\r\n             * @type {int}\r\n             */\n            this.videoScaledHeight = 0;\n\n            /**\r\n             * what type of data comes back with frame data event\r\n             * @type {string}\r\n             * @default imagedataurl\r\n             */\n            this.frameDataMode = 'none';\n\n            /**\r\n             * determines whether to use the canvas element for display instead of the video element\r\n             * @type {boolean}\r\n             * @default false\r\n             */\n            this.useCanvasForDisplay = false;\n\n            /**\r\n             * canvas filter function (manipulate pixels)\r\n             * @type {method}\r\n             * @default 0 ms\r\n             */\n            this.canvasFilter = null;\n\n            /**\r\n             * WebGL filter name\r\n             * @type {string}\r\n             * @default passthrough\r\n             */\n            this._glFilter = 'passthrough';\n\n            /**\r\n             * When reading pixels to a buffer, the image is upside down, correct this with the texture reading\r\n             * @type {Boolean}\r\n             * @default false\r\n             */\n            this._glFlipTexture = false;\n\n            /**\r\n             * When the texture read (_glReadFlipCorrection) is true, this makes the display go upside down, correct the canvas by inverse scaling in the vertical\r\n             * @type {Boolean}\r\n             * @default false\r\n             */\n            this._flipCanvas = false;\n\n            /**\r\n             * WebGL shaders object for filter lookup\r\n             * @type {Object}\r\n             * @default passthrough\r\n             */\n            if (window.ccwc && ccwc.image && ccwc.image.webgl.shaders) {\n                this._glFilterLibrary = this._glFilterLibrary ? this._glFilterLibrary : ccwc.image.webgl.shaders;\n            }\n\n            /**\r\n             * refresh interval when using the canvas for display\r\n             * @type {int}\r\n             * @default 0 ms\r\n             */\n            this.canvasRefreshInterval = 0;\n\n            /**\r\n             * video element\r\n             * @type {HTMLElement}\r\n             * @private\r\n             */\n            this.videoElement = null;\n\n            /**\r\n             * camera sources list\r\n             * @type {Array}\r\n             */\n            this.cameraSources = [];\n\n            /**\r\n             * canvas element\r\n             * @type {Canvas}\r\n             * @private\r\n             */\n            this.canvasElement = null;\n\n            /**\r\n             * component shadow root\r\n             * @type {ShadowRoot}\r\n             * @private\r\n             */\n            this.root = null;\n\n            /**\r\n             * interval timer to draw frame redraws\r\n             * @type {int}\r\n             * @private\r\n             */\n            this.tick = null;\n\n            /**\r\n             * canvas context\r\n             * @type {CanvasContext}\r\n             * @private\r\n             */\n            this.canvasctx = null;\n\n            /**\r\n             * has the canvas context been overridden from the outside?\r\n             * @type {boolean}\r\n             * @private\r\n             */\n            this._canvasOverride = false;\n\n            /**\r\n             * width of component\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.width = 0;\n\n            /**\r\n             * height of component\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.height = 0;\n\n            /**\r\n             * left offset for letterbox of video\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.letterBoxLeft = 0;\n\n            /**\r\n             * top offset for letterbox of video\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.letterBoxTop = 0;\n\n            /**\r\n             * aspect ratio of video\r\n             * @type {number}\r\n             */\n            this.aspectRatio = 0;\n\n            /**\r\n             * render scale for canvas frame data\r\n             * best used when grabbing frame data at a different size than the shown video\r\n             * @attribute canvasScale\r\n             * @type {float}\r\n             * @default 1.0\r\n             */\n            this.canvasScale = 1.0;\n        }\n\n        /**\r\n         * on video playing handler\r\n         */\n    }, {\n        key: 'onPlaying',\n        value: function onPlaying() {\n            this.isPlaying = true;\n            var event = new CustomEvent('videoplaying', {\n                detail: {\n                    source: this.source,\n                    videoElement: this.videoElement,\n                    videoWidth: this.videoScaledWidth,\n                    videoHeight: this.videoScaledHeight,\n                    width: this.width,\n                    height: this.height } });\n            this.dispatchEvent(event);\n\n            this.canvasElement.width = this.videoScaledWidth * this.canvasScale;\n            this.canvasElement.height = this.videoScaledHeight * this.canvasScale;\n\n            var ctxstring = this._useWebGL ? 'webgl' : '2d';\n            if (!this._canvasOverride) {\n                this.canvasctx = this.canvasElement.getContext(ctxstring);\n            }\n\n            if (this._useWebGL) {\n                var filter = ccwc.image.webgl.filter.createFilterFromName(this._glFilter, this._glFilterLibrary);\n\n                // texture comes in upside down. We can flip it according to this boolean\n                // the cost is that the texture is now flipped on the display, but flipCanvas (if true) will flip accordingly\n                this.glProps = ccwc.image.webgl.filter.createRenderProps(this.canvasctx, filter, this.videoElement, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n                this.glProps.flipTexture = this._glFlipTexture;\n            }\n        }\n\n        /**\r\n         * update canvas dimensions when resized\r\n         * @private\r\n         */\n    }, {\n        key: 'onResize',\n        value: function onResize() {\n            // set size properties based on component height\n            this.width = this.offsetWidth;\n            this.height = this.offsetHeight;\n\n            // calculate aspect ratio\n            this.aspectRatio = this.videoElement.videoWidth / this.videoElement.videoHeight;\n            this.videoScaledWidth = this.width;\n            this.videoScaledHeight = this.height;\n\n            // calculate letterbox borders\n            var componentAspectRatio = this.width / this.height;\n            if (componentAspectRatio < this.aspectRatio) {\n                this.videoScaledHeight = this.width / this.aspectRatio;\n                this.letterBoxTop = this.height / 2 - this.videoScaledHeight / 2;\n                this.letterBoxLeft = 0;\n            } else if (componentAspectRatio > this.aspectRatio) {\n                this.videoScaledWidth = this.height * this.aspectRatio;\n                this.letterBoxLeft = this.width / 2 - this.videoScaledWidth / 2;\n                this.letterBoxTop = 0;\n            } else {\n                this.letterBoxTop = 0;\n                this.letterBoxLeft = 0;\n            }\n\n            // set video/canvas to component size\n            this.videoElement.setAttribute('width', this.videoScaledWidth);\n            this.videoElement.setAttribute('height', this.videoScaledHeight);\n            this.canvasElement.setAttribute('width', this.videoScaledWidth);\n            this.canvasElement.setAttribute('height', this.videoScaledHeight);\n            this.videoElement.style.top = this.letterBoxTop + 'px';\n            this.videoElement.style.left = this.letterBoxLeft + 'px';\n            this.canvasElement.style.top = this.letterBoxTop + 'px';\n            this.canvasElement.style.left = this.letterBoxLeft + 'px';\n        }\n    }, {\n        key: 'getCurrentFrameData',\n\n        /**\r\n         * get image data for current frame\r\n         * @param {boolean} mode data mode (binary or base64)\r\n         * @param {boolean} noredraw do not perform redraw (can be wasteful)\r\n         * @return {object} image data\r\n         */\n        value: function getCurrentFrameData(mode, noredraw) {\n            var data, filtered;\n            if (!mode) {\n                mode = this.frameDataMode;\n            }\n            if (!noredraw) {\n                if (this._useWebGL) {\n                    ccwc.image.webgl.filter.render(this.glProps, [0]);\n                } else {\n                    this.canvasctx.drawImage(this.videoElement, 0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n\n                    if (this.canvasFilter) {\n                        filtered = this.canvasctx.getImageData(0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n                        this.canvasctx.putImageData(this.canvasFilter(filtered), 0, 0, 0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n                    }\n                }\n            }\n\n            switch (mode) {\n                case 'binary':\n                    var base64Data = data.replace('data:image/png;base64', '');\n                    var binaryData = new Buffer(base64Data, 'base64');\n                    data = binaryData;\n                    break;\n\n                case 'imagedataurl':\n                    data = this.canvasElement.toDataURL('image/png');\n                    break;\n\n                case 'imagedata':\n                    if (!filtered) {\n                        if (this._useWebGL) {\n                            data = ccwc.image.webgl.filter.getCanvasPixels(this.glProps);\n                        } else {\n                            data = this.canvasctx.getImageData(0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n                        }\n                    } else {\n                        // save some CPU cycles if we already did this\n                        data = filtered;\n                    }\n                    break;\n            }\n\n            return data;\n        }\n    }, {\n        key: 'setCameraSourceByIndex',\n\n        /**\r\n         * set camera source by index\r\n         * @param {int} index\r\n         */\n        value: function setCameraSourceByIndex(index) {\n            if (!index || index >= this.cameraSources.length) {\n                console.log(\"Video Source Index does not exist\");return;\n            }\n            this.setCameraSourceByID(this.cameraSources[index].id);\n        }\n    }, {\n        key: 'setCameraSourceByID',\n\n        /**\r\n         * set camera source by id\r\n         * @param {String} id\r\n         */\n        value: function setCameraSourceByID(id) {\n            navigator.webkitGetUserMedia({ video: { optional: [{ sourceId: id }] } }, this.onCameraStream.bind(this), function () {});\n        }\n    }, {\n        key: 'refreshCameraSources',\n\n        /**\r\n         * refresh camera sources\r\n         */\n        value: function refreshCameraSources() {\n            var _this = this;\n\n            this.cameraSources = [];\n            MediaStreamTrack.getSources(function (sources) {\n                _this.onCameraSources(sources);\n            });\n        }\n    }, {\n        key: 'onCameraStream',\n\n        /**\r\n         * on camera video source stream\r\n         * @param stream\r\n         * @private\r\n         */\n        value: function onCameraStream(stream) {\n            var _this2 = this;\n\n            this.videoElement.src = URL.createObjectURL(stream);\n            this.videoElement.onloadedmetadata = function (e) {\n                _this2.onResize();\n            };\n        }\n    }, {\n        key: 'onCameraSources',\n\n        /**\r\n         * on camera sources callback\r\n         * @param {array} sources found\r\n         * @private\r\n         */\n        value: function onCameraSources(sources) {\n            var storageIndex = 0;\n            for (var i = 0; i < sources.length; i++) {\n                if (sources[i].kind == 'video') {\n                    var label = sources[i].label;\n                    if (label == \"\") {\n                        label = \"video \" + Number(storageIndex + 1);\n                    }\n                    sources[storageIndex] = sources[i].id;\n                    this.cameraSources.push({ label: label, id: sources[i].id });\n                    storageIndex++;\n                }\n            }\n\n            var event = new CustomEvent('camerasfound', { detail: { cameras: this.cameraSources } });\n            this.dispatchEvent(event);\n            if (this._source) {\n                this.source = this._source;\n            }\n        }\n    }, {\n        key: 'saveCurrentFrameToFile',\n\n        /**\r\n         * save current frame to file\r\n         * @param {String} path file path\r\n         */\n        value: function saveCurrentFrameToFile(path) {\n            var fs = require('fs');\n            if (!fs) {\n                throw new Error('This method uses Node.js functionality, and you are not running within Node.js');\n            }\n            var data = this.getCurrentFrameData().toString('binary');\n            fs.writeFileSync(path, data, 'binary');\n        }\n    }, {\n        key: 'parseAttributes',\n\n        /**\r\n         * parse attributes on element\r\n         * @private\r\n         */\n        value: function parseAttributes() {\n            if (this.hasAttribute('useCamera')) {\n                this._useCamera = true;\n            } else {\n                this._useCamera = false;\n            }\n\n            if (this.hasAttribute('src')) {\n                this._source = this.getAttribute('src');\n            }\n\n            if (this.hasAttribute('useCanvasForDisplay')) {\n                this.useCanvasForDisplay = true;\n            } else {\n                this.useCanvasForDisplay = false;\n            }\n\n            if (this.hasAttribute('frameDataMode')) {\n                this.frameDataMode = this.getAttribute('frameDataMode');\n            }\n\n            if (this.hasAttribute('canvasRefreshInterval')) {\n                this.canvasRefreshInterval = parseInt(this.getAttribute('canvasRefreshInterval'));\n            }\n\n            if (this.hasAttribute('canvasScale')) {\n                this.canvasScale = parseFloat(this.getAttribute('canvasScale'));\n            }\n\n            if (this.hasAttribute('usewebgl')) {\n                this._useWebGL = true;\n            }\n\n            if (this.hasAttribute('glfilter')) {\n                this._glFilter = this.getAttribute('glFilter');\n            }\n\n            if (this.hasAttribute('flipCanvas')) {\n                this._flipCanvas = true;\n            }\n\n            if (this.hasAttribute('glFlipTexture')) {\n                this._glFlipTexture = true;\n            }\n\n            if (this.canvasRefreshInterval === 0 && this.useCanvasForDisplay) {\n                console.log('Warning: Using canvas for display, but the canvas refresh interval is not set or set to 0. Setting refresh interval to 250ms.');\n                this.canvasRefreshInterval = 250;\n            }\n        }\n    }, {\n        key: 'createdCallback',\n\n        /**\r\n         * element created callback\r\n         * @private\r\n         */\n        value: function createdCallback() {\n            this.setProperties();\n            this.parseAttributes();\n        }\n    }, {\n        key: 'attachedCallback',\n\n        /**\r\n         * element attached callback\r\n         * @private\r\n         */\n        value: function attachedCallback() {\n            var _this3 = this;\n\n            var template = this.owner.querySelector(\"template\");\n            var clone = template.content.cloneNode(true);\n            this.root = this.createShadowRoot();\n            this.root.appendChild(clone);\n\n            window.addEventListener('HTMLImportsLoaded', function (e) {\n                _this3.onResize();\n            });\n\n            this.videoElement = this.root.querySelector('#vid');\n            this.videoElement.addEventListener('play', function (e) {\n                return _this3.onPlaying(e);\n            });\n            this.canvasElement = this.root.querySelector('#canvas');\n\n            if (this._flipCanvas) {\n                this.canvasElement.style.transform = 'scale(1, -1)';\n            }\n            this.videoElement.onloadedmetadata = function (e) {\n                _this3.onResize();\n            };\n\n            this.source = this._source;\n            if (this.useCanvasForDisplay) {\n                this.videoElement.style.display = 'none';\n            } else {\n                this.canvasElement.style.display = 'none';\n            }\n\n            if (this.canvasRefreshInterval > 0) {\n                this.tick = setInterval(function () {\n                    if (_this3.width === 0 || _this3.height === 0) {\n                        return;\n                    }\n                    if (!_this3.isPlaying) {\n                        return;\n                    }\n                    var event = new CustomEvent('frameupdate', { detail: {\n                            framedata: _this3.getCurrentFrameData(),\n                            canvascontext: _this3.canvasctx,\n                            videoWidth: _this3.videoScaledWidth * _this3.canvasScale,\n                            videoHeight: _this3.videoScaledHeight * _this3.canvasScale,\n                            videoLeft: _this3.letterBoxLeft * _this3.canvasScale,\n                            videoTop: _this3.letterBoxTop * _this3.canvasScale,\n                            width: _this3.width * _this3.canvasScale,\n                            height: _this3.height * _this3.canvasScale } });\n\n                    _this3.dispatchEvent(event);\n                }, this.canvasRefreshInterval);\n            }\n\n            this.isReady = true;\n            var event = new CustomEvent('ready');\n            this.dispatchEvent(event);\n        }\n    }, {\n        key: 'detachedCallback',\n\n        /**\r\n         * element detached callback\r\n         * @private\r\n         */\n        value: function detachedCallback() {}\n    }, {\n        key: 'attributeChangedCallback',\n\n        /**\r\n         * attributeChangedCallback\r\n         * @private\r\n         * @param {String} attr attribute changed\r\n         * @param {*} oldVal old value\r\n         * @param {*} newVal new value\r\n         */\n        value: function attributeChangedCallback(attr, oldVal, newVal) {}\n    }, {\n        key: 'source',\n\n        /**\r\n         * set video source\r\n         * @param {string | int} src video source uri\r\n         */\n        set: function set(src) {\n            if (!src) {\n                return;\n            }\n            this._source = src;\n\n            if (this._useCamera && this.cameraSources.length === 0) {\n                this.refreshCameraSources();\n                return;\n            }\n\n            if (this._useCamera || parseInt(src) === src) {\n                this.setCameraSourceByIndex(src);\n            } else if (this._useCamera) {\n                this.setCameraSourceByID(src);\n            } else {\n                this.videoElement.src = src;\n            }\n        },\n\n        /**\r\n         * get video source\r\n         * @return {string | int} src video source uri\r\n         */\n        get: function get() {\n            return this._source;\n        }\n    }, {\n        key: 'glFilterLibrary',\n\n        /**\r\n         * set filter dictionary for WebGL\r\n         * @param filters\r\n         */\n        set: function set(filters) {\n            this._glFilterLibrary = filters;\n        }\n    }, {\n        key: 'canvasContext',\n\n        /**\r\n         * get canvas context for drawing into it\r\n         * @return {object} context canvas context\r\n         */\n        get: function get() {\n            return this.canvasctx;\n        },\n\n        /**\r\n         * get canvas context for drawing into it\r\n         * @param {object} context canvas context\r\n         */\n        set: function set(context) {\n            this.canvasctx = context;\n            this._canvasOverride = true;\n        }\n    }]);\n\n    return CCWCVideo;\n})(HTMLElement);\n\nCCWCVideo.prototype.owner = (document._currentScript || document.currentScript).ownerDocument;\ndocument.registerElement('ccwc-video', CCWCVideo);\n//# sourceMappingURL=ccwc-video.js.map\n"],"file":"ccwc-glvideo.js","sourceRoot":"/source/"}