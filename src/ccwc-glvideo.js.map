{"version":3,"names":[],"mappings":"","sources":["ccwc-glvideo.js"],"sourcesContent":["if (!window.ccwc) { ccwc = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image.webgl) { ccwc.image.webgl = {}; }\r\n\r\nccwc.image.webgl.filter = {\r\n    /**\r\n     * create filter from shaders\r\n     * @param vertexShader\r\n     * @param fragmentShader\r\n     * @returns {{vertexShader: *, fragmentShader: *}}\r\n     */\r\n    createFilterFromShaders: function(vertexShader, fragmentShader) {\r\n        return { vertexShader: vertexShader, fragmentShader: fragmentShader };\r\n    },\r\n\r\n    /**\r\n     * create a filter from filter name\r\n     * @param name\r\n     * @param memory space/variable to pull shader from\r\n     */\r\n    createFilterFromName: function(name, shaderloc) {\r\n        if (!shaderloc) {\r\n            shaderloc = ccwc.image.webgl.shaders;\r\n        }\r\n        if (!shaderloc[name]) {\r\n            console.log('Shader ', name, 'not found in ', shaderloc, ' using a passthrough shader instead');\r\n            shaderloc = ccwc.image.webgl.shaders;\r\n            name = 'passthrough';\r\n        }\r\n        var vtx = shaderloc[name].vertex;\r\n        var frg = shaderloc[name].fragment;\r\n        return this.createFilterFromShaders(vtx, frg);\r\n    },\r\n\r\n    /**\r\n     * create object for render\r\n     * @param {Object}params\r\n     */\r\n    createRenderObject: function(params) {\r\n        var props = {};\r\n\r\n        props.gl = params.gl;\r\n        props.width = props.gl.canvas.width;\r\n        props.height = props.gl.canvas.height;\r\n\r\n        if (params.width) { props.width = params.width; }\r\n        if (params.height) { props.height = params.height; }\r\n\r\n        props.filter = params.filter;\r\n        props.textures = new ccwc.image.webgl.textures(props.width,props.height);\r\n\r\n        props.canvas2DHelper = document.createElement('canvas');\r\n        props.canvas2DHelper.width = props.width;\r\n        props.canvas2DHelper.height = props.height;\r\n        props.canvas2DHelperContext = props.canvas2DHelper.getContext('2d');\r\n\r\n        props.uniforms = new ccwc.image.webgl.uniforms();\r\n        props.textures = new ccwc.image.webgl.textures(props.gl, props.width, props.height);\r\n\r\n        if (params.textures) {\r\n            for (var c = 0; c < params.textures.length; c++) {\r\n                props.textures.add(params.textures[c].name, params.textures[c].texture, params.textures[c].index, params.textures[c].pixelStore);\r\n            }\r\n        }\r\n\r\n        if (params.uniforms) {\r\n            for (var c = 0; c < params.uniforms.length; c++) {\r\n                props.uniforms.add(params.uniforms[c].name, params.uniforms[c].type, params.uniforms[c].values);\r\n            }\r\n        }\r\n\r\n        if (params.autorender) {\r\n            return this.render(props);\r\n        }\r\n\r\n        return props;\r\n    },\r\n\r\n    /**\r\n     * render WebGL filter on current texture\r\n     * @param glprops\r\n     * @param refreshTextureIndices texture refresh indices (optional)\r\n     * @returns {*}\r\n     */\r\n    render: function(glprops) {\r\n        if (!glprops.isInitialized) {\r\n            var vertexShader = glprops.gl.createShader(glprops.gl.VERTEX_SHADER);\r\n            glprops.gl.shaderSource(vertexShader, glprops.filter.vertexShader);\r\n            glprops.gl.compileShader(vertexShader);\r\n\r\n            var fragmentShader = glprops.gl.createShader(glprops.gl.FRAGMENT_SHADER);\r\n            glprops.gl.shaderSource(fragmentShader, glprops.filter.fragmentShader);\r\n            glprops.gl.compileShader(fragmentShader);\r\n\r\n            glprops.program = glprops.gl.createProgram();\r\n            glprops.gl.attachShader(glprops.program, vertexShader);\r\n            glprops.gl.attachShader(glprops.program, fragmentShader);\r\n            glprops.gl.linkProgram(glprops.program);\r\n            glprops.gl.useProgram(glprops.program);\r\n\r\n            var positionLocation = glprops.gl.getAttribLocation(glprops.program, 'a_position');\r\n            var texCoordBuffer = glprops.gl.createBuffer();\r\n            var rectCoordBuffer = glprops.gl.createBuffer();\r\n            var texCoords = new Float32Array([0.0,  0.0, 1.0,  0.0, 0.0,  1.0, 0.0,  1.0, 1.0,  0.0, 1.0,  1.0]);\r\n            var rectCoords = new Float32Array([0, 0, glprops.textures.width, 0, 0, glprops.textures.height, 0,\r\n                glprops.textures.height, glprops.textures.width, 0, glprops.textures.width, glprops.textures.height]);\r\n\r\n            glprops.gl.bindBuffer(glprops.gl.ARRAY_BUFFER, texCoordBuffer);\r\n            glprops.gl.bufferData(glprops.gl.ARRAY_BUFFER, texCoords, glprops.gl.STATIC_DRAW);\r\n\r\n            var texCoordLocation = glprops.gl.getAttribLocation(glprops.program, 'a_texCoord');\r\n            glprops.gl.enableVertexAttribArray(texCoordLocation);\r\n            glprops.gl.vertexAttribPointer(texCoordLocation, 2, glprops.gl.FLOAT, false, 0, 0);\r\n\r\n            glprops.uniforms.add('u_resolution', ccwc.image.webgl.uniforms.UNIFORM2f, [glprops.gl.canvas.width, glprops.gl.canvas.height]);\r\n            glprops.uniforms.add('f_resolution', ccwc.image.webgl.uniforms.UNIFORM2f, [glprops.gl.canvas.width, glprops.gl.canvas.height]);\r\n\r\n            glprops.gl.bindBuffer(glprops.gl.ARRAY_BUFFER, rectCoordBuffer);\r\n            glprops.gl.enableVertexAttribArray(positionLocation);\r\n            glprops.gl.vertexAttribPointer(positionLocation, 2, glprops.gl.FLOAT, false, 0, 0);\r\n            glprops.gl.bufferData(glprops.gl.ARRAY_BUFFER, rectCoords, glprops.gl.STATIC_DRAW);\r\n        }\r\n\r\n        glprops.textures.initializeNewTextures(glprops.program);\r\n        glprops.textures.refreshScene();\r\n        glprops.uniforms.updateProgram(glprops.gl, glprops.program);\r\n\r\n        glprops.gl.drawArrays(glprops.gl.TRIANGLES, 0, 6);\r\n        glprops.isInitialized = true;\r\n\r\n        return glprops;\r\n    },\r\n\r\n    /**\r\n     * read pixels from GL context\r\n     * @param glProps\r\n     */\r\n    getCanvasPixels: function(glprops) {\r\n        var glctx = glprops.gl;\r\n        if (!glprops.pixelarray) {\r\n            glprops.pixelarray = new Uint8Array(glctx.canvas.width * glctx.canvas.height * 4);\r\n        }\r\n        glctx.readPixels(0, 0, glctx.canvas.width, glctx.canvas.height, glctx.RGBA, glctx.UNSIGNED_BYTE, glprops.pixelarray);\r\n        var imgData = glprops.canvas2DHelperContext.createImageData(glctx.canvas.width, glctx.canvas.height);\r\n        imgData.data.set(new Uint8ClampedArray(glprops.pixelarray));\r\n        return imgData;\r\n    }\r\n};\nccwc.image.webgl.shaders = {\n  \"freichen_edge_detection\": {\n    \"fragment\": \"precision mediump float; uniform sampler2D u_image0; varying vec2 v_texCoord; uniform vec2 f_resolution; vec2 texel = vec2(1.0 / f_resolution.x, 1.0 / f_resolution.y); mat3 G[9];  const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 ); const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 ); const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 ); const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 ); const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 ); const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 ); const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 ); const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 ); const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );  void main(void) {      G[0] = g0,     G[1] = g1,     G[2] = g2,     G[3] = g3,     G[4] = g4,     G[5] = g5,     G[6] = g6,     G[7] = g7,     G[8] = g8;      mat3 I;     float cnv[9];     vec3 sampl;      for (float i=0.0; i<3.0; i++) {         for (float j=0.0; j<3.0; j++) {             sampl = texture2D(u_image0, v_texCoord + texel * vec2(i-1.0,j-1.0) ).rgb;             I[int(i)][int(j)] = length(sampl);         }     }      for (int i=0; i<9; i++) {         float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);         cnv[i] = dp3 * dp3;     }      float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);     float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);      gl_FragColor = vec4(vec3(sqrt(M/S)), texture2D( u_image0, v_texCoord ).a ); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"greyscale\": {\n    \"fragment\": \"precision mediump float; varying vec2 v_texCoord;  uniform sampler2D u_image0;  void main(void) {     vec4 px = texture2D(u_image0, v_texCoord);     float avg = (px.r + px.g + px.b)/3.0;     gl_FragColor = vec4(avg, avg, avg, px.a); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"passthrough\": {\n    \"fragment\": \"precision mediump float; uniform sampler2D u_image0; varying vec2 v_texCoord;  void main() {     gl_FragColor = texture2D(u_image0, v_texCoord); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"sepia\": {\n    \"fragment\": \"precision mediump float; varying vec2 v_texCoord;  uniform sampler2D u_image0; uniform vec4 light; uniform vec4 dark; uniform float desat; uniform float toned;  const mat4 coeff = mat4(     0.393, 0.349, 0.272, 1.0,     0.796, 0.686, 0.534, 1.0,     0.189, 0.168, 0.131, 1.0,     0.0, 0.0, 0.0, 1.0 );  void main(void) {     vec4 sourcePixel = texture2D(u_image0, v_texCoord);     gl_FragColor = coeff * sourcePixel; }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  },\n  \"sobel_edge_detection\": {\n    \"fragment\": \"precision mediump float; varying vec2 v_texCoord; uniform sampler2D u_image0; uniform vec2 f_resolution;  void main(void) {     float x = 1.0 / f_resolution.x;     float y = 1.0 / f_resolution.y;     vec4 horizEdge = vec4( 0.0 );     horizEdge -= texture2D( u_image0, vec2( v_texCoord.x - x, v_texCoord.y - y ) ) * 1.0;     horizEdge -= texture2D( u_image0, vec2( v_texCoord.x - x, v_texCoord.y     ) ) * 2.0;     horizEdge -= texture2D( u_image0, vec2( v_texCoord.x - x, v_texCoord.y + y ) ) * 1.0;     horizEdge += texture2D( u_image0, vec2( v_texCoord.x + x, v_texCoord.y - y ) ) * 1.0;     horizEdge += texture2D( u_image0, vec2( v_texCoord.x + x, v_texCoord.y     ) ) * 2.0;     horizEdge += texture2D( u_image0, vec2( v_texCoord.x + x, v_texCoord.y + y ) ) * 1.0;     vec4 vertEdge = vec4( 0.0 );     vertEdge -= texture2D( u_image0, vec2( v_texCoord.x - x, v_texCoord.y - y ) ) * 1.0;     vertEdge -= texture2D( u_image0, vec2( v_texCoord.x    , v_texCoord.y - y ) ) * 2.0;     vertEdge -= texture2D( u_image0, vec2( v_texCoord.x + x, v_texCoord.y - y ) ) * 1.0;     vertEdge += texture2D( u_image0, vec2( v_texCoord.x - x, v_texCoord.y + y ) ) * 1.0;     vertEdge += texture2D( u_image0, vec2( v_texCoord.x    , v_texCoord.y + y ) ) * 2.0;     vertEdge += texture2D( u_image0, vec2( v_texCoord.x + x, v_texCoord.y + y ) ) * 1.0;     vec3 edge = sqrt((horizEdge.rgb * horizEdge.rgb) + (vertEdge.rgb * vertEdge.rgb));      gl_FragColor = vec4( edge, texture2D( u_image0, v_texCoord ).a ); }\",\n    \"vertex\": \"attribute vec2 a_position; attribute vec2 a_texCoord; uniform vec2 u_resolution; varying vec2 v_texCoord;  void main() {     vec2 zeroToOne = a_position / u_resolution;     vec2 zeroToTwo = zeroToOne * 2.0;     vec2 clipSpace = zeroToTwo - 1.0;     gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);     v_texCoord = a_texCoord; }\"\n  }\n};\nif (!window.ccwc) { ccwc = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image.webgl) { ccwc.image.webgl = {}; }\r\n\r\nccwc.image.webgl.textures = function(gl, width, height) {\r\n\r\n    /** internal texture array */\r\n    this._textures = {};\r\n\r\n    /** width */\r\n    this.width = width;\r\n\r\n    /** height */\r\n    this.height = height;\r\n\r\n    /** gl context */\r\n    this.gl = gl;\r\n\r\n    /** uninitialized textures */\r\n    this._unitialized = [];\r\n\r\n    /** dirty textures (needs updating) */\r\n    this._dirty = [];\r\n\r\n    /** texture indices */\r\n    this.textureIndices = [];\r\n\r\n    /**\r\n     * add a texture\r\n     * @param {String} name\r\n     * @param {Object} texture\r\n     * @param {Integer} glindex\r\n     * @param {Array} pixelstore\r\n     */\r\n    this.add = function(name, texture, glindex, pixelstore) {\r\n        if (!glindex) {\r\n            glindex = 0;\r\n            while (this.textureIndices.indexOf(glindex) !== -1) {\r\n                glindex ++;\r\n            }\r\n        }\r\n\r\n        if (!pixelstore) {\r\n            pixelstore = [];\r\n        }\r\n        this.textureIndices.push(glindex);\r\n\r\n        this._textures[name] = {\r\n            name: name,\r\n            glindex: glindex,\r\n            texture: texture,\r\n            gltexture: gl.createTexture(),\r\n            initialized: false,\r\n            pixelStore: pixelstore,\r\n            dirty: true };\r\n\r\n        this._unitialized.push(this._textures[name]);\r\n    };\r\n\r\n    /**\r\n     * update a uniform\r\n     * @param name name of texture\r\n     * @param texture\r\n     */\r\n    this.update = function(name, texture) {\r\n        if (texture) {\r\n            this._textures[name].texture = texture;\r\n        }\r\n        this._textures[name].dirty = true;\r\n        this._dirty.push(this._textures[name]);\r\n    };\r\n\r\n    /**\r\n     * refresh scene with updated textures\r\n     */\r\n    this.refreshScene = function() {\r\n        for (var c = 0; c < this._dirty.length; c++) {\r\n            this.gl.activeTexture(this.gl['TEXTURE' + this._dirty[c].glindex]);\r\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this._dirty[c].gltexture);\r\n            this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this._dirty[c].texture);\r\n        }\r\n        this._dirty = [];\r\n    };\r\n\r\n    /**\r\n     * initialize new textures\r\n     * @param program\r\n     */\r\n    this.initializeNewTextures = function(program) {\r\n        if (this._unitialized.length === 0) { return; }\r\n        var gl = this.gl;\r\n        for (var c = 0; c < this._unitialized.length; c++) {\r\n            this._unitialized[c].location = gl.getUniformLocation(program, 'u_image' + this._unitialized[c].glindex);\r\n            gl.uniform1i(this._unitialized[c].location, this._unitialized[c].glindex);\r\n            gl.activeTexture(gl['TEXTURE' + this._unitialized[c].glindex]);\r\n            gl.bindTexture(gl.TEXTURE_2D, this._unitialized[c].gltexture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\r\n            for (var d = 0; d < this._unitialized[c].pixelStore.length; d++) {\r\n                gl.pixelStorei(gl[this._unitialized[c].pixelStore[d].property], this._unitialized[c].pixelStore[d].value);\r\n            }\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._unitialized[c].texture);\r\n\r\n            this._unitialized[c].initialized = true;\r\n            this._unitialized[c].dirty = false;\r\n        }\r\n        this._unitialized = [];\r\n    };\r\n};\nif (!window.ccwc) { ccwc = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image) { ccwc.image = {}; }\r\nif (!window.ccwc.image.webgl) { ccwc.image.webgl = {}; }\r\n\r\nccwc.image.webgl.uniforms = function() {\r\n    /**\r\n     * internal mapping of uniforms\r\n     * @type {{}}\r\n     * @private\r\n     */\r\n    this._uniforms = {};\r\n\r\n    /**\r\n     * add a uniform\r\n     * @param type type of uniform (1f, 2f, 3f, 4f, 1i, 2i, 3i, 4u\r\n     */\r\n    this.add = function(name, type, values) {\r\n        this._uniforms[name] = { name: name, type: type, values: values, dirty: true };\r\n    };\r\n\r\n    /**\r\n     * update a uniform\r\n     * @param type type of uniform (1f, 2f, 3f, 4f, 1i, 2i, 3i, 4u\r\n     */\r\n    this.update = function(name, values) {\r\n        this._uniforms[name].values = values;\r\n        this._uniforms[name].dirty = true;\r\n    };\r\n\r\n\r\n    /**\r\n     * update uniforms on GL context and program\r\n     * @param gl WebGL context\r\n     * @param program\r\n     */\r\n    this.updateProgram = function(gl, program) {\r\n        for (var c in this._uniforms) {\r\n            if (this._uniforms[c].dirty) {\r\n                var u = gl.getUniformLocation(program, this._uniforms[c].name);\r\n                switch (this._uniforms[c].type) {\r\n                    case '1f':\r\n                        gl.uniform1f(u, this._uniforms[c].values[0]);\r\n                        break;\r\n\r\n                    case '2f':\r\n                        gl.uniform2f(u, this._uniforms[c].values[0], this._uniforms[c].values[1]);\r\n                        break;\r\n\r\n                    case '3f':\r\n                        gl.uniform3f(u, this._uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2]);\r\n                        break;\r\n\r\n                    case '4f':\r\n                        gl.uniform4f(u, this._uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2], this._uniforms[c].values[3]);\r\n                        break;\r\n\r\n                    case '1i':\r\n                        gl.uniform1i(u, this._uniforms[c].values[0]);\r\n                        break;\r\n\r\n                    case '2i':\r\n                        gl.uniform2i(u, this._uniforms[c].values[0], this._uniforms[c].values[1]);\r\n                        break;\r\n\r\n                    case '3i':\r\n                        gl.uniform3i(u, this._.uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2]);\r\n                        break;\r\n\r\n                    case '4i':\r\n                        gl.uniformif(u, this._uniforms[c].values[0], this._uniforms[c].values[1], this._uniforms[c].values[2], this._uniforms[c].values[3]);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\n\r\nccwc.image.webgl.uniforms.UNIFORM1f = '1f';\r\nccwc.image.webgl.uniforms.UNIFORM2f = '2f';\r\nccwc.image.webgl.uniforms.UNIFORM3f = '3f';\r\nccwc.image.webgl.uniforms.UNIFORM4f = '4f';\r\n\r\nccwc.image.webgl.uniforms.UNIFORM1i = '1i';\r\nccwc.image.webgl.uniforms.UNIFORM2i = '2i';\r\nccwc.image.webgl.uniforms.UNIFORM3i = '3i';\r\nccwc.image.webgl.uniforms.UNIFORM4i = '4i';\n/**\r\n * CCWCVideo supports both video files and camera feeds\r\n * Blit your video to a canvas, get frame data, scale the frame/canvas output, and render video to an external canvas of your choosing\r\n */\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CCWCVideo = (function (_HTMLElement) {\n    _inherits(CCWCVideo, _HTMLElement);\n\n    function CCWCVideo() {\n        _classCallCheck(this, CCWCVideo);\n\n        _get(Object.getPrototypeOf(CCWCVideo.prototype), 'constructor', this).apply(this, arguments);\n    }\n\n    _createClass(CCWCVideo, [{\n        key: 'setProperties',\n\n        /**\r\n         * initialize default class properties\r\n         * @private\r\n         */\n        value: function setProperties() {\n            /**\r\n             * video source file or stream\r\n             * @type {string}\r\n             * @private\r\n             */\n            this._source = '';\n\n            /**\r\n             * use webgl\r\n             * @type {boolean}\r\n             * @private\r\n             */\n            this._useWebGL = false;\n\n            /**\r\n             * use camera\r\n             * @type {boolean}\r\n             * @private\r\n             */\n            this._useCamera = false;\n\n            /**\r\n             * is component ready\r\n             * @type {boolean}\r\n             */\n            this.isReady = false;\n\n            /**\r\n             * is video playing\r\n             * @type {boolean}\r\n             */\n            this.isPlaying = false;\n\n            /**\r\n             * width of scaled video\r\n             * @type {int}\r\n             */\n            this.videoScaledWidth = 0;\n\n            /**\r\n             * width of scaled video\r\n             * @type {int}\r\n             */\n            this.videoScaledWidth = 0;\n\n            /**\r\n             * height of scaled video\r\n             * @type {int}\r\n             */\n            this.videoScaledHeight = 0;\n\n            /**\r\n             * what type of data comes back with frame data event\r\n             * @type {string}\r\n             * @default imagedataurl\r\n             */\n            this.frameDataMode = 'none';\n\n            /**\r\n             * determines whether to use the canvas element for display instead of the video element\r\n             * @type {boolean}\r\n             * @default false\r\n             */\n            this.useCanvasForDisplay = false;\n\n            /**\r\n             * canvas filter function (manipulate pixels)\r\n             * @type {method}\r\n             * @default 0 ms\r\n             */\n            this.canvasFilter = null;\n\n            /**\r\n             * When the texture read (_glReadFlipCorrection) is true, this makes the display go upside down, correct the canvas by inverse scaling in the vertical\r\n             * @type {Boolean}\r\n             * @default false\r\n             */\n            this._flipCanvas = false;\n\n            /**\r\n             * refresh interval when using the canvas for display\r\n             * @type {int}\r\n             * @default 0 ms\r\n             */\n            this.canvasRefreshInterval = 0;\n\n            /**\r\n             * video element\r\n             * @type {HTMLElement}\r\n             * @private\r\n             */\n            this.videoElement = null;\n\n            /**\r\n             * camera sources list\r\n             * @type {Array}\r\n             */\n            this.cameraSources = [];\n\n            /**\r\n             * canvas element\r\n             * @type {Canvas}\r\n             * @private\r\n             */\n            this.canvasElement = null;\n\n            /**\r\n             * component shadow root\r\n             * @type {ShadowRoot}\r\n             * @private\r\n             */\n            this.root = null;\n\n            /**\r\n             * interval timer to draw frame redraws\r\n             * @type {int}\r\n             * @private\r\n             */\n            this.tick = null;\n\n            /**\r\n             * canvas context\r\n             * @type {CanvasContext}\r\n             * @private\r\n             */\n            this.canvasctx = null;\n\n            /**\r\n             * has the canvas context been overridden from the outside?\r\n             * @type {boolean}\r\n             * @private\r\n             */\n            this._canvasOverride = false;\n\n            /**\r\n             * width of component\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.width = 0;\n\n            /**\r\n             * height of component\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.height = 0;\n\n            /**\r\n             * left offset for letterbox of video\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.letterBoxLeft = 0;\n\n            /**\r\n             * top offset for letterbox of video\r\n             * @type {int}\r\n             * @default 0\r\n             */\n            this.letterBoxTop = 0;\n\n            /**\r\n             * aspect ratio of video\r\n             * @type {number}\r\n             */\n            this.aspectRatio = 0;\n\n            /**\r\n             * render scale for canvas frame data\r\n             * best used when grabbing frame data at a different size than the shown video\r\n             * @attribute canvasScale\r\n             * @type {float}\r\n             * @default 1.0\r\n             */\n            this.canvasScale = 1.0;\n        }\n\n        /**\r\n         * on video playing handler\r\n         */\n    }, {\n        key: 'onPlaying',\n        value: function onPlaying() {\n            this.isPlaying = true;\n            var event = new CustomEvent('videoplaying', {\n                detail: {\n                    source: this.source,\n                    videoElement: this.videoElement,\n                    videoWidth: this.videoScaledWidth,\n                    videoHeight: this.videoScaledHeight,\n                    width: this.width,\n                    height: this.height } });\n            this.dispatchEvent(event);\n\n            this.canvasElement.width = this.videoScaledWidth * this.canvasScale;\n            this.canvasElement.height = this.videoScaledHeight * this.canvasScale;\n\n            var ctxstring = this._useWebGL ? 'webgl' : '2d';\n            if (!this._canvasOverride) {\n                this.canvasctx = this.canvasElement.getContext(ctxstring);\n            }\n\n            if (this._useWebGL) {\n                this.webglProperties.renderobj = this.webglProperties.setupHandler.apply(this, [this.webglProperties]);\n                var event = new CustomEvent('webglsetup', { detail: { properties: this.webglProperties } });\n                this.dispatchEvent(event);\n            }\n        }\n\n        /**\r\n         * update canvas dimensions when resized\r\n         * @private\r\n         */\n    }, {\n        key: 'onResize',\n        value: function onResize() {\n            // set size properties based on component height\n            this.width = this.offsetWidth;\n            this.height = this.offsetHeight;\n\n            // calculate aspect ratio\n            this.aspectRatio = this.videoElement.videoWidth / this.videoElement.videoHeight;\n            this.videoScaledWidth = this.width;\n            this.videoScaledHeight = this.height;\n\n            // calculate letterbox borders\n            var componentAspectRatio = this.width / this.height;\n            if (componentAspectRatio < this.aspectRatio) {\n                this.videoScaledHeight = this.width / this.aspectRatio;\n                this.letterBoxTop = this.height / 2 - this.videoScaledHeight / 2;\n                this.letterBoxLeft = 0;\n            } else if (componentAspectRatio > this.aspectRatio) {\n                this.videoScaledWidth = this.height * this.aspectRatio;\n                this.letterBoxLeft = this.width / 2 - this.videoScaledWidth / 2;\n                this.letterBoxTop = 0;\n            } else {\n                this.letterBoxTop = 0;\n                this.letterBoxLeft = 0;\n            }\n\n            // set video/canvas to component size\n            this.videoElement.setAttribute('width', this.videoScaledWidth);\n            this.videoElement.setAttribute('height', this.videoScaledHeight);\n            this.canvasElement.setAttribute('width', this.videoScaledWidth);\n            this.canvasElement.setAttribute('height', this.videoScaledHeight);\n            this.videoElement.style.top = this.letterBoxTop + 'px';\n            this.videoElement.style.left = this.letterBoxLeft + 'px';\n            this.canvasElement.style.top = this.letterBoxTop + 'px';\n            this.canvasElement.style.left = this.letterBoxLeft + 'px';\n        }\n    }, {\n        key: 'getCurrentFrameData',\n\n        /**\r\n         * get image data for current frame\r\n         * @param {boolean} mode data mode (binary or base64)\r\n         * @param {boolean} noredraw do not perform redraw (can be wasteful)\r\n         * @return {object} image data\r\n         */\n        value: function getCurrentFrameData(mode, noredraw) {\n            var data, filtered;\n            if (!mode) {\n                mode = this.frameDataMode;\n            }\n            if (!noredraw) {\n                if (this._useWebGL) {\n                    this.webglProperties.renderobj.textures.update('video');\n                    this.webglProperties.renderHandler(this.webglProperties.renderobj);\n                } else {\n                    this.canvasctx.drawImage(this.videoElement, 0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n\n                    if (this.canvasFilter) {\n                        filtered = this.canvasctx.getImageData(0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n                        this.canvasctx.putImageData(this.canvasFilter(filtered), 0, 0, 0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n                    }\n                }\n            }\n\n            switch (mode) {\n                case 'binary':\n                    var base64Data = data.replace('data:image/png;base64', '');\n                    var binaryData = new Buffer(base64Data, 'base64');\n                    data = binaryData;\n                    break;\n\n                case 'imagedataurl':\n                    data = this.canvasElement.toDataURL('image/png');\n                    break;\n\n                case 'imagedata':\n                    if (!filtered) {\n                        if (this._useWebGL) {\n                            data = ccwc.image.webgl.filter.getCanvasPixels(this.webglProperties.renderobj);\n                        } else {\n                            data = this.canvasctx.getImageData(0, 0, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n                        }\n                    } else {\n                        // save some CPU cycles if we already did this\n                        data = filtered;\n                    }\n                    break;\n            }\n\n            return data;\n        }\n    }, {\n        key: 'setCameraSourceByIndex',\n\n        /**\r\n         * set camera source by index\r\n         * @param {int} index\r\n         */\n        value: function setCameraSourceByIndex(index) {\n            if (!index || index >= this.cameraSources.length) {\n                console.log(\"Video Source Index does not exist\");return;\n            }\n            this.setCameraSourceByID(this.cameraSources[index].id);\n        }\n    }, {\n        key: 'setCameraSourceByID',\n\n        /**\r\n         * set camera source by id\r\n         * @param {String} id\r\n         */\n        value: function setCameraSourceByID(id) {\n            navigator.webkitGetUserMedia({ video: { optional: [{ sourceId: id }] } }, this.onCameraStream.bind(this), function () {});\n        }\n    }, {\n        key: 'refreshCameraSources',\n\n        /**\r\n         * refresh camera sources\r\n         */\n        value: function refreshCameraSources() {\n            var _this = this;\n\n            this.cameraSources = [];\n            MediaStreamTrack.getSources(function (sources) {\n                _this.onCameraSources(sources);\n            });\n        }\n    }, {\n        key: 'onCameraStream',\n\n        /**\r\n         * on camera video source stream\r\n         * @param stream\r\n         * @private\r\n         */\n        value: function onCameraStream(stream) {\n            var _this2 = this;\n\n            this.videoElement.src = URL.createObjectURL(stream);\n            this.videoElement.onloadedmetadata = function (e) {\n                _this2.onResize();\n            };\n        }\n    }, {\n        key: 'onCameraSources',\n\n        /**\r\n         * on camera sources callback\r\n         * @param {array} sources found\r\n         * @private\r\n         */\n        value: function onCameraSources(sources) {\n            var storageIndex = 0;\n            for (var i = 0; i < sources.length; i++) {\n                if (sources[i].kind == 'video') {\n                    var label = sources[i].label;\n                    if (label == \"\") {\n                        label = \"video \" + Number(storageIndex + 1);\n                    }\n                    sources[storageIndex] = sources[i].id;\n                    this.cameraSources.push({ label: label, id: sources[i].id });\n                    storageIndex++;\n                }\n            }\n\n            var event = new CustomEvent('camerasfound', { detail: { cameras: this.cameraSources } });\n            this.dispatchEvent(event);\n            if (this._source) {\n                this.source = this._source;\n            }\n        }\n    }, {\n        key: 'saveCurrentFrameToFile',\n\n        /**\r\n         * save current frame to file\r\n         * @param {String} path file path\r\n         */\n        value: function saveCurrentFrameToFile(path) {\n            var fs = require('fs');\n            if (!fs) {\n                throw new Error('This method uses Node.js functionality, and you are not running within Node.js');\n            }\n            var data = this.getCurrentFrameData().toString('binary');\n            fs.writeFileSync(path, data, 'binary');\n        }\n    }, {\n        key: 'webglSetupHandler',\n\n        /**\r\n         * setup handler for WebGL Scene\r\n         * @param {Object} props webgl properties\r\n         * @return renderobj\r\n         */\n        value: function webglSetupHandler(props) {\n            var filter;\n            if (props.vertexShader && props.fragmentShader) {\n                filter = ccwc.image.webgl.filter.createFilterFromShaders(props.vertexShader, props.fragmentShader);\n            } else {\n                filter = ccwc.image.webgl.filter.createFilterFromName(props.filter, props.filterLibrary);\n            }\n\n            props.textures.push({\n                name: 'video',\n                texture: document.querySelector('ccwc-video').videoElement,\n                pixelStore: [{ property: 'UNPACK_FLIP_Y_WEBGL', value: this.webglProperties.flipTextureY }],\n                index: 0 });\n\n            return ccwc.image.webgl.filter.createRenderObject({\n                gl: this.canvasctx,\n                filter: filter,\n                textures: props.textures\n            });\n            // texture comes in upside down. We can flip it according to this boolean\n            // the cost is that the texture is now flipped on the display, but flipCanvas (if true) will flip accordingly\n            // var renderer = ccwc.image.webgl.filter.createRenderProps(this.canvasctx, filter, props.textures, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);\n            // renderer.flipTexture = props.flipTexture;\n            //return renderobj;\n        }\n    }, {\n        key: 'webglRenderHandler',\n\n        /**\r\n         * render handler for WebGL Scene\r\n         * @param renderobj WebGL render properties\r\n         */\n        value: function webglRenderHandler(renderobj) {\n            ccwc.image.webgl.filter.render(renderobj);\n        }\n    }, {\n        key: 'parseAttributes',\n\n        /**\r\n         * parse attributes on element\r\n         * @private\r\n         */\n        value: function parseAttributes() {\n            if (this.hasAttribute('useCamera') || this.hasAttribute('usecamera')) {\n                this._useCamera = true;\n            } else {\n                this._useCamera = false;\n            }\n\n            if (this.hasAttribute('src')) {\n                this._source = this.getAttribute('src');\n            }\n\n            if (this.hasAttribute('useCanvasForDisplay')) {\n                this.useCanvasForDisplay = true;\n            } else {\n                this.useCanvasForDisplay = false;\n            }\n\n            if (this.hasAttribute('frameDataMode')) {\n                this.frameDataMode = this.getAttribute('frameDataMode');\n            }\n\n            if (this.hasAttribute('canvasRefreshInterval')) {\n                this.canvasRefreshInterval = parseInt(this.getAttribute('canvasRefreshInterval'));\n            }\n\n            if (this.hasAttribute('canvasScale')) {\n                this.canvasScale = parseFloat(this.getAttribute('canvasScale'));\n            }\n\n            if (this.hasAttribute('useWebGL')) {\n                this._useWebGL = true;\n                var props = this.getAttribute('useWebGL');\n                if (props) {\n                    props = JSON.parse(props);\n                    if (props.flipTextureY) {\n                        this.webglProperties.flipTextureY = props.flipTextureY;\n                    }\n                    if (props.filter) {\n                        this.webglProperties.filter = props.filter;\n                    }\n                }\n            }\n\n            if (this.hasAttribute('flipCanvas')) {\n                this._flipCanvas = true;\n            }\n\n            if (this.canvasRefreshInterval === 0 && this.useCanvasForDisplay) {\n                console.log('Warning: Using canvas for display, but the canvas refresh interval is not set or set to 0. Setting refresh interval to 250ms.');\n                this.canvasRefreshInterval = 250;\n            }\n        }\n    }, {\n        key: 'createdCallback',\n\n        /**\r\n         * element created callback\r\n         * @private\r\n         */\n        value: function createdCallback() {\n            this.webglProperties = {\n                flipTextureY: false,\n                filterLibrary: ccwc.image.webgl.shaders,\n                setupHandler: this.webglSetupHandler,\n                renderHandler: this.webglRenderHandler,\n                filter: 'passthrough',\n                textures: []\n            };\n\n            this.setProperties();\n            this.parseAttributes();\n        }\n    }, {\n        key: 'attachedCallback',\n\n        /**\r\n         * element attached callback\r\n         * @private\r\n         */\n        value: function attachedCallback() {\n            var _this3 = this;\n\n            var template = this.owner.querySelector(\"template\");\n            var clone = template.content.cloneNode(true);\n            this.root = this.createShadowRoot();\n            this.root.appendChild(clone);\n\n            window.addEventListener('HTMLImportsLoaded', function (e) {\n                _this3.onResize();\n            });\n\n            this.videoElement = this.root.querySelector('#vid');\n            this.videoElement.addEventListener('play', function (e) {\n                return _this3.onPlaying(e);\n            });\n            this.canvasElement = this.root.querySelector('#canvas');\n\n            if (this._flipCanvas) {\n                this.canvasElement.style.transform = 'scale(1, -1)';\n            }\n            this.videoElement.onloadedmetadata = function (e) {\n                _this3.onResize();\n            };\n\n            this.source = this._source;\n            if (this.useCanvasForDisplay) {\n                this.videoElement.style.display = 'none';\n            } else {\n                this.canvasElement.style.display = 'none';\n            }\n\n            if (this.canvasRefreshInterval > 0) {\n                this.tick = setInterval(function () {\n                    if (_this3.width === 0 || _this3.height === 0) {\n                        return;\n                    }\n                    if (!_this3.isPlaying) {\n                        return;\n                    }\n                    var event = new CustomEvent('frameupdate', { detail: {\n                            framedata: _this3.getCurrentFrameData(),\n                            canvascontext: _this3.canvasctx,\n                            videoWidth: _this3.videoScaledWidth * _this3.canvasScale,\n                            videoHeight: _this3.videoScaledHeight * _this3.canvasScale,\n                            videoLeft: _this3.letterBoxLeft * _this3.canvasScale,\n                            videoTop: _this3.letterBoxTop * _this3.canvasScale,\n                            width: _this3.width * _this3.canvasScale,\n                            height: _this3.height * _this3.canvasScale } });\n\n                    _this3.dispatchEvent(event);\n                }, this.canvasRefreshInterval);\n            }\n\n            this.isReady = true;\n            var event = new CustomEvent('ready');\n            this.dispatchEvent(event);\n        }\n    }, {\n        key: 'detachedCallback',\n\n        /**\r\n         * element detached callback\r\n         * @private\r\n         */\n        value: function detachedCallback() {}\n    }, {\n        key: 'attributeChangedCallback',\n\n        /**\r\n         * attributeChangedCallback\r\n         * @private\r\n         * @param {String} attr attribute changed\r\n         * @param {*} oldVal old value\r\n         * @param {*} newVal new value\r\n         */\n        value: function attributeChangedCallback(attr, oldVal, newVal) {}\n    }, {\n        key: 'source',\n\n        /**\r\n         * set video source\r\n         * @param {string | int} src video source uri\r\n         */\n        set: function set(src) {\n            if (!src) {\n                return;\n            }\n            this._source = src;\n\n            if (this._useCamera && this.cameraSources.length === 0) {\n                this.refreshCameraSources();\n                return;\n            }\n\n            if (this._useCamera || parseInt(src) === src) {\n                this.setCameraSourceByIndex(src);\n            } else if (this._useCamera) {\n                this.setCameraSourceByID(src);\n            } else {\n                this.videoElement.src = src;\n            }\n        },\n\n        /**\r\n         * get video source\r\n         * @return {string | int} src video source uri\r\n         */\n        get: function get() {\n            return this._source;\n        }\n    }, {\n        key: 'canvasContext',\n\n        /**\r\n         * get canvas context for drawing into it\r\n         * @return {object} context canvas context\r\n         */\n        get: function get() {\n            return this.canvasctx;\n        },\n\n        /**\r\n         * get canvas context for drawing into it\r\n         * @param {object} context canvas context\r\n         */\n        set: function set(context) {\n            this.canvasctx = context;\n            this._canvasOverride = true;\n        }\n    }]);\n\n    return CCWCVideo;\n})(HTMLElement);\n\nCCWCVideo.prototype.owner = (document._currentScript || document.currentScript).ownerDocument;\ndocument.registerElement('ccwc-video', CCWCVideo);\n//# sourceMappingURL=ccwc-video.js.map\n"],"file":"ccwc-glvideo.js","sourceRoot":"/source/"}