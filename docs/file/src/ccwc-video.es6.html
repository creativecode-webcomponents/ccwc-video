<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/ccwc-video.es6 | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ccwc-video.es6~CCWCVideo.html">CCWCVideo</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/ccwc-video.es6</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * CCWCVideo supports both video files and camera feeds
 * Blit your video to a canvas, get frame data, scale the frame/canvas output, and render video to an external canvas of your choosing
 */
class CCWCVideo extends HTMLElement {

    /**
     * initialize default class properties
     * @private
     */
    setProperties() {
        /**
         * video source file or stream
         * @type {string}
         * @private
         */
        this._source = &apos;&apos;;

        /**
         * use camera
         * @type {boolean}
         * @private
         */
        this._useCamera = false;

        /**
         * is component ready
         * @type {boolean}
         */
        this.isReady = false;

        /**
         * width of scaled video
         * @type {int}
         */
        this.videoScaledWidth = 0;

        /**
         * width of scaled video
         * @type {int}
         */
        this.videoScaledWidth = 0;

        /**
         * height of scaled video
         * @type {int}
         */
        this.videoScaledHeight = 0;

        /**
         * what type of data comes back with frame data event
         * @type {string}
         * @default imagedataurl
         */
        this.frameDataMode = &apos;imagedataurl&apos;;

        /**
         * determines whether to use the canvas element for display instead of the video element
         * @type {boolean}
         * @default false
         */
        this.useCanvasForDisplay = false;

        /**
         * refresh interval when using the canvas for display
         * @type {int}
         * @default 0 ms
         */
        this.canvasRefreshInterval = 0;

        /**
         * video element
         * @type {HTMLElement}
         * @private
         */
        this.videoElement = null;

        /**
         * camera sources list
         * @type {Array}
         */
        this.cameraSources = [];

        /**
         * canvas element
         * @type {Canvas}
         * @private
         */
        this.canvasElement = null;

        /**
         * component shadow root
         * @type {ShadowRoot}
         * @private
         */
        this.root = null;

        /**
         * interval timer to draw frame redraws
         * @type {int}
         * @private
         */
        this.tick = null;

        /**
         * canvas context
         * @type {CanvasContext}
         * @private
         */
        this.canvasctx = null;

        /**
         * width of component
         * @type {int}
         * @default 0
         */
        this.width = 0;

        /**
         * height of component
         * @type {int}
         * @default 0
         */
        this.height = 0;

        /**
         * left offset for letterbox of video
         * @type {int}
         * @default 0
         */
        this.letterBoxLeft = 0;

        /**
         * top offset for letterbox of video
         * @type {int}
         * @default 0
         */
        this.letterBoxTop = 0;

        /**
         * aspect ratio of video
         * @type {number}
         */
        this.aspectRatio = 0;

        /**
         * render scale for canvas frame data
         * best used when grabbing frame data at a different size than the shown video
         * @attribute canvasScale
         * @type {float}
         * @default 1.0
         */
        this.canvasScale = 1.0;
    }

    /**
     * update canvas dimensions when resized
     * @private
     */
    onResize() {
        // set size properties based on component height
        this.width = this.offsetWidth;
        this.height = this.offsetHeight;

        // set video/canvas to component size
        this.videoElement.setAttribute(&apos;width&apos;, this.width);
        this.videoElement.setAttribute(&apos;height&apos;, this.height);
        this.canvasElement.setAttribute(&apos;width&apos;, this.width);
        this.canvasElement.setAttribute(&apos;height&apos;, this.height);

        // calculate aspect ratio
        this.aspectRatio = this.videoElement.videoWidth / this.videoElement.videoHeight;
        this.videoScaledWidth = this.width;
        this.videoScaledHeight = this.height;

        // calculate letterbox borders
        var componentAspectRatio = this.width/this.height;
        if (componentAspectRatio &lt; this.aspectRatio) {
            this.videoScaledHeight = this.width / this.aspectRatio;
            this.letterBoxTop = this.height/2 - this.videoScaledHeight/2;
            this.letterBoxLeft = 0;
        } else if (componentAspectRatio &gt; this.aspectRatio) {
            this.videoScaledWidth = this.height * this.aspectRatio;
            this.letterBoxLeft = this.width/2 - this.videoScaledWidth/2;
            this.letterBoxTop = 0;
        } else {
            this.letterBoxTop = 0;
            this.letterBoxLeft = 0;
        }
    };


    /**
     * set video source
     * @param {string | int} src video source uri
     */
    set source(src) {
        if (!src) { return; }
        this._source = src;

        if (this._useCamera &amp;&amp; this.cameraSources.length === 0) {
            this.refreshCameraSources();
            return;
        }

        if (this._useCamera || parseInt(src) === src) {
            this.setCameraSourceByIndex(src);
        } else if (this._useCamera) {
            this.setCameraSourceByID(src);
        } else {
            this.videoElement.src = src;
        }
    };

    /**
     * get video source
     * @return {string | int} src video source uri
     */
    get source() {
        return this._source;
    };

    /**
     * get canvas context for drawing into it
     * @return {object} context canvas context
     */
    get canvasContext() {
        return this.canvasctx;
    };

    /**
     * get canvas context for drawing into it
     * @param {object} context canvas context
     */
    set canvasContext(context) {
        this.canvasctx = context;
    };

    /**
     * get image data for current frame
     * @param {boolean} mode data mode (binary or base64)
     * @param {boolean} noredraw do not perform redraw (can be wasteful)
     * @return {object} image data
     */
    getCurrentFrameData(mode, noredraw) {
        var data;
        if (!mode) {
            mode = this.frameDataMode;
        }
        if (!noredraw) {
            this.canvasctx.canvas.width = this.width * this.canvasScale;
            this.canvasctx.canvas.height = this.height * this.canvasScale;
            this.canvasctx.drawImage(
                this.videoElement,
                this.letterBoxLeft,
                this.letterBoxTop,
                this.videoScaledWidth * this.canvasScale,
                this.videoScaledHeight * this.canvasScale);
        }

        switch (mode) {
            case &apos;binary&apos;:
                var base64Data = data.replace(&apos;data:image/png;base64&apos;, &apos;&apos;);
                var binaryData = new Buffer(base64Data, &apos;base64&apos;);
                data = binaryData;
                break;

            case &apos;imagedataurl&apos;:
                data = this.canvasElement.toDataURL(&apos;image/png&apos;);
                break;

            case &apos;imagedata&apos;:
                data = this.canvasctx.getImageData(this.letterBoxLeft, this.letterBoxTop, this.videoScaledWidth * this.canvasScale, this.videoScaledHeight * this.canvasScale);
                break;
        }
        return data;
    };

    /**
     * set camera source by index
     * @param {int} index
     */
    setCameraSourceByIndex(index) {
        if (!index || index &gt;= this.cameraSources.length) { console.log(&quot;Video Source Index does not exist&quot;); return; }
        this.setCameraSourceByID(this.cameraSources[index].id);
    };

    /**
     * set camera source by id
     * @param {String} id
     */
    setCameraSourceByID(id) {
        navigator.webkitGetUserMedia(
            { video: {optional: [{sourceId: id }]}},
            this.onCameraStream.bind(this),
            function() {}
        );
    };

    /**
     * refresh camera sources
     */
    refreshCameraSources() {
        this.cameraSources = [];
        MediaStreamTrack.getSources( sources =&gt; {
            this.onCameraSources(sources);
        });
    };

    /**
     * on camera video source stream
     * @param stream
     * @private
     */
    onCameraStream(stream) {
        this.videoElement.src = URL.createObjectURL(stream);
        this.videoElement.onloadedmetadata = e =&gt; {
            this.onResize();
        };
    };

    /**
     * on camera sources callback
     * @param {array} sources found
     * @private
     */
    onCameraSources(sources) {
        var storageIndex = 0;
        for (var i=0; i &lt; sources.length; i++) {
            if (sources[i].kind == &apos;video&apos;) {
                var label = sources[i].label;
                if (label == &quot;&quot;) { label = &quot;video &quot; + Number(storageIndex+1); }
                sources[storageIndex] = sources[i].id;
                this.cameraSources.push({ label: label, id: sources[i].id });
                storageIndex++;
            }
        }

        var event = new CustomEvent(&apos;camerasfound&apos;, { detail: { cameras: this.cameraSources } });
        this.dispatchEvent(event);
        if (this._source) { this.source = this._source; }
    };

    /**
     * save current frame to file
     * @param {String} path file path
     */
    saveCurrentFrameToFile(path) {
        var fs = require(&apos;fs&apos;);
        if (!fs) {
            throw new Error(&apos;This method uses Node.js functionality, and you are not running within Node.js&apos;);
        }
        var data = this.getCurrentFrameData().toString(&apos;binary&apos;);
        fs.writeFileSync(path, data, &apos;binary&apos;);
    };

    /**
     * parse attributes on element
     * @private
     */
    parseAttributes() {
        if (this.hasAttribute(&apos;useCamera&apos;)) {
            this._useCamera = true;
        } else {
            this._useCamera = false;
        }

        if (this.hasAttribute(&apos;src&apos;)) {
            this._source = this.getAttribute(&apos;src&apos;);
        }

        if (this.hasAttribute(&apos;useCanvasForDisplay&apos;)) {
            this.useCanvasForDisplay = true;
        } else {
            this.useCanvasForDisplay = false;
        }

        if (this.hasAttribute(&apos;frameDataMode&apos;)) {
            this.frameDataMode = this.getAttribute(&apos;frameDataMode&apos;);
        }

        if (this.hasAttribute(&apos;canvasRefreshInterval&apos;)) {
            this.canvasRefreshInterval = parseInt(this.getAttribute(&apos;canvasRefreshInterval&apos;));
        }

        if (this.hasAttribute(&apos;canvasScale&apos;)) {
            this.canvasScale = parseFloat(this.getAttribute(&apos;canvasScale&apos;));
        }

        if (this.canvasRefreshInterval === 0 &amp;&amp; this.useCanvasForDisplay) {
            console.log(&apos;Warning: Using canvas for display, but the canvas refresh interval is not set or set to 0. Setting refresh interval to 250ms.&apos;);
            this.canvasRefreshInterval = 250;
        }
    };

    /**
     * element created callback
     * @private
     */
    createdCallback() {
        this.setProperties();
        this.parseAttributes();
    };

    /**
     * element attached callback
     * @private
     */
    attachedCallback() {
        let template = this.owner.querySelector(&quot;template&quot;);
        let clone = template.content.cloneNode(true);
        this.root = this.createShadowRoot();
        this.root.appendChild(clone);

        window.addEventListener(&apos;HTMLImportsLoaded&apos;, e =&gt; {
            this.onResize();
        });

        this.videoElement = this.root.querySelector(&apos;#vid&apos;);
        this.canvasElement = this.root.querySelector(&apos;#canvas&apos;);
        this.videoElement.onloadedmetadata = e =&gt; {
            this.onResize();
        };
        this.source = this._source;
        if (this.useCanvasForDisplay) {
            this.videoElement.style.display = &apos;none&apos;;
        } else {
            this.canvasElement.style.display = &apos;none&apos;;
        }

        if (this.canvasRefreshInterval &gt; 0) {
            this.tick = setInterval(() =&gt; {
                if (this.width === 0 || this.height === 0) { return; }
                var event = new CustomEvent(&apos;frameupdate&apos;, { detail: {
                    framedata: this.getCurrentFrameData(),
                    canvascontext: this.canvasctx,
                    videoWidth: this.videoScaledWidth * this.canvasScale,
                    videoHeight: this.videoScaledHeight * this.canvasScale,
                    videoLeft: this.letterBoxLeft * this.canvasScale,
                    videoTop: this.letterBoxTop * this.canvasScale,
                    width: this.width * this.canvasScale,
                    height: this.height * this.canvasScale }});

                this.dispatchEvent(event);
            }, this.canvasRefreshInterval);
        }
        this.canvasctx = this.canvasElement.getContext(&apos;2d&apos;);

        this.isReady = true;
        var event = new CustomEvent(&apos;ready&apos;);
        this.dispatchEvent(event);
    };

    /**
     * element detached callback
     * @private
     */
    detachedCallback() {};


    /**
     * attributeChangedCallback
     * @private
     * @param {String} attr attribute changed
     * @param {*} oldVal old value
     * @param {*} newVal new value
     */
    attributeChangedCallback(attr, oldVal, newVal) {};

}

CCWCVideo.prototype.owner = (document._currentScript || document.currentScript).ownerDocument;
document.registerElement(&apos;ccwc-video&apos;, CCWCVideo);</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
